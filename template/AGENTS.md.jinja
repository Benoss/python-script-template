# Copilot Instructions for This Project

## Overview

{% if project_type == "script" %}
This project is a modern Python application
{% elif project_type == "django" %}
This is a Django web application built with modern tooling and best practices.
{% endif %}
Code quality is enforced using [Ruff](https://docs.astral.sh/ruff/) for linting and formating and [Ty](https://github.com/astral-sh/ruff/tree/main/crates/ty) for type checking.

**Editor Setup**: VS Code is configured to use Ty's language server for real-time type checking (not Pylance). Type errors will appear as you type, matching exactly what `task lint` checks in CI.

## General Tone

- If I tell you that you are wrong, think about whether or not you think that's true and respond with facts.
- Avoid apologizing or making conciliatory statements.
- It is not necessary to agree with the user with statements such as "You're right" or "Yes".
- Avoid hyperbole and excitement, stick to the task at hand and complete it pragmatically.
- Avoid words like seamless, captivating

## Workflow Rules

- **ALWAYS run `task lint` before telling me that work is finished**
  - This is mandatory for every feature, bugfix, or code change
  - Fix all linting errors or the CI/CD will fail

- Run `task test` to verify all tests pass after code changes
- Update documentation when adding new features or changing behavior

## Best Practices

### 1. Code Style & Linting

- **Always run `task lint` before completing any work** - This is mandatory
- Follow [PEP8](https://peps.python.org/pep-0008/) style guidelines.
- Use type hints everywhere.
- Sometimes you will have to use type: ignore always ask before adding those
- You can also ask to add a global ignore rule for directory if it makes sense, example assert are allowed in the test directory
- Keep imports organized and sorted (stdlib, third-party, local) unused imports are removed (Ruff will check this).
- Prefer f-strings for string formatting.
- `open()` should be replaced by pathlib `Path.open()`
- use logguru.logger instead of print or logging.
- use dotenv for environment variables in a .env file
- First line of docstring should be in imperative mood
- Avoid having more than 5 params to functions, use a dataclass or pydantic model if it makes sense
- If in need of a http client prefer httpx over requests
- Always ask first before adding 3rd party libraries and provide choices if there are multiple candidates
- Prefer small, composable functions over large monolithic scripts. But do not create too many functions
- If you need to run a python file use uv run myfile.py this will ensure that it is using the correct virtualenv

### 2. Project Structure

{% if project_type == "script" %}
- Keep env variables in local .env file (ignored by git), secrets should NEVER be hardcoded in the python files
- Output files from scripts should be by default in tmp/ folder at the root of the project
- Do not log credentials or full payloads with sensitive data.
- Fixtures should be kept into a fixtures/ folder at the root of the project
{% elif project_type == "django" %}
- **Apps Organization**: All Django apps MUST be placed in the `{{ project_slug_underscore }}/apps/` directory
  - Example: `{{ project_slug_underscore }}/apps/core/`, `{{ project_slug_underscore }}/apps/users/`
  - Each app should have a clear, single responsibility
  - Use `uv run manage.py startapp app_name {{ project_slug_underscore }}/apps/app_name` to create new apps
- **Settings Split**: Use environment-specific settings files in `{{ project_slug_underscore }}/settings/`
  - `base.py` - Shared settings
  - `local.py` - Development (default)
  - `staging.py` - Staging environment
  - `prod.py` - Production with security hardening
- **Environment Variables**: Store in `.env` file, load with django-environ
  - Never hardcode secrets (SECRET_KEY, passwords, API keys)
  - Use `env()` helper from settings to read variables
- **Static Files**: Place custom CSS/JS in `static/` directory
  - Tailwind input: `static/css/input.css` (includes @import and @theme config)
  - Compiled output: `static/css/output.css` (auto-generated via bunx)
  - No tailwind.config.js needed (Tailwind 4.1 uses CSS-based config)
- **Templates**: Place shared templates in `templates/` directory
  - Components go in `templates/components/` for django-cotton
  - App-specific templates can go in app's `templates/` folder
- **Technical Decisions**: Document architectural decisions in `specs/` directory
  - Root `specs/` for cross-cutting concerns (devops-infrastructure.md, etc.)
  - **Each Django app should have their own specfile. called app-{appslug}.md**
  - Check existing specs before making architectural decisions
  - **Update specs when decisions change or evolve**
  - When doing diagrams always use Mermaid
  - See [specs/README.md](specs/README.md) for guidelines
{% endif %}


### 3. Testing
{% if project_type == "script" %}
- Write tests for all business logic and models if asked to do so
- Use [pytest](https://docs.pytest.org/) as the test runner.
- Place tests in a `tests/` directory.
{% elif project_type == "django" %}
- Use [pytest](https://docs.pytest.org/) with [pytest-django](https://pytest-django.readthedocs.io/)
- Place project-wide tests in `tests/` directory
- Place app-specific tests in each app's `tests.py` or `tests/` directory
- Test views, models, forms, and management commands
- Use factory-boy for creating test data
- Run tests with: `task test` or `uv run pytest`
{% endif %}


### 4. Dependency Management
{% if project_type == "script" %}
- Use uv for managing packages via uv pip
- Use a requirements.txt file for production dependencies.
- Use a requirements_dev.txt file for development dependencies.
- Use `pyproject.toml` for project metadata and linter configuration.
{% elif project_type == "django" %}
- **Package Manager**: Use UV exclusively (pip is blocked)
  - Add packages: `uv add package-name`
  - Add dev packages: `uv add --dev package-name`
  - Sync dependencies: `task setup` or `uv sync --extra dev`
- Dependencies are defined in `pyproject.toml`
- Never use `pip install` directly
{% endif %}
{% if project_type == "django" %}

## Django-Specific Best Practices

### 1. Models & Database

- **Always update the `init_data` management command when adding new models**
  - After creating a model, add seed data to `{{ project_slug_underscore }}/apps/core/management/commands/init_data.py`
  - This ensures a complete testing experience for local development
  - Create realistic sample data that demonstrates the feature
- Run migrations after model changes:
  - `task makemigrations` - Create migration files
  - `task migrate` - Apply migrations
- Use `loguru.logger` for logging, not `print()` or Django's logging
- Add `__str__` methods to all models for better admin display
- Use Django's `get_object_or_404` and `get_list_or_404` for views

### 2. Views & URLs

- Prefer Class-Based Views (CBVs) for standard CRUD operations
- Use Function-Based Views (FBVs) for complex logic or simple endpoints
- Always name URL patterns: `path('', HomeView.as_view(), name='home')`
- Use app namespaces: `app_name = 'core'` in `urls.py`
- Reverse URLs in templates: `{% raw %}{% url 'core:home' %}{% endraw %}`

### 3. Templates & Frontend

- **django-cotton**: Use for reusable components
  - Create components in `templates/components/`
  - Example: `<c-button>Click me</c-button>`
  - Pass props: `<c-card title="Hello" />` 
  - Use slots for content: `<c-slot />` or named slots
- **Tailwind CSS 4.1**: Use utility classes for styling
  - Configuration via CSS in `static/css/input.css` (no tailwind.config.js needed)
  - Uses bunx (no Node.js/npm dependency required)
  - Run `task tailwind-watch` during development (auto-runs bunx)
  - Build for production: `task tailwind-build`
  - Follow Tailwind conventions (mobile-first, utility classes)
  - Extract repeated patterns into django-cotton components
- Keep templates DRY - use `{% raw %}{% extends "base.html" %}{% endraw %}` and blocks
- Use template tags: `{% raw %}{% load static %}{% endraw %}`, `{% raw %}{% load cotton %}{% endraw %}`

### 4. APIs (When Needed)

- **Prefer Django Ninja over Django REST Framework**
  - More modern, faster, and simpler than DRF
  - Automatic OpenAPI/Swagger documentation
  - Better type hints support
  - Install: `uv add django-ninja`
  - Mention this preference but don't install by default

### 5. Admin Panel

- Register all models in `admin.py`
- Customize admin display with `list_display`, `list_filter`, `search_fields`
- Use `@admin.register(Model)` decorator for cleaner code
- Create custom admin actions for bulk operations
- Test admin interface as part of QA

### 6. Management Commands

- **Always seed data for new features**
  - When adding a feature with new models, update `init_data` command
  - Provide realistic, useful test data
  - Use `get_or_create()` to make command idempotent
  - Log actions with loguru: `logger.info("Created X")`
- Test management commands: `task init-data`
- Follow Django's command structure with `handle()` method

### 7. Security

- Never commit `.env` file or secrets
- Use environment variables for sensitive data
- Keep `DEBUG=False` in production
- Use HTTPS in production (enforced in `prod.py` settings)
- Validate all user input
- Use Django's built-in protection: CSRF, XSS, SQL injection

### 8. Performance

- Use `select_related()` and `prefetch_related()` to avoid N+1 queries
- Add database indexes for frequently queried fields
- Use Django's caching framework for expensive operations
- Monitor query count in development with Django Debug Toolbar (optional)
{% endif %}

### 5. Documentation

- Document all public functions and classes with docstrings. Keep them short on to the point
- Write comments as full sentences ending with a period. 
- Only add comments when it adds value for understanding
- Maintain a `README.md` with setup and usage instructions.

## Linting Commands

{% if project_type == "script" %}
Run these commands via Task:
- `task lint` - Run all linting tools (Ruff + Ty)
- Or individually:
  - `uv run ruff check --fix .` - Fix linting issues
  - `uv run ruff format .` - Format code
  - `uv run ty check .` - Type checking
{% elif project_type == "django" %}
Run linting with Task:
- `task lint` - Run all linting tools (Ruff + Ty)
- Or individually:
  - `uv run ruff check --fix .` - Fix linting issues
  - `uv run ruff format .` - Format code
  - `uv run ty check .` - Type checking

Other useful commands:
- `task test` - Run all tests
- `task runserver` - Start development server
- `task migrate` - Apply database migrations
- `task init-data` - Seed database with test data
{% endif %}

